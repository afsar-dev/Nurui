{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "rotating-earth",
  "type": "registry:component",
  "dependencies": [
    "d3"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "./src/components/nurui/rotating-earth-demo.tsx",
      "content": "import RotatingEarth from \"@/components/nurui/rotating-earth\";\n\nexport default function RotatingEarthDemo() {\n  return (\n    <main className=\"flex justify-center items-center bg-[#80eeb40d] rounded-3xl m-20\">\n      <RotatingEarth width={700} height={500} />\n    </main>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "./src/components/nurui/rotating-earth.tsx",
      "content": "/* eslint-disable @typescript-eslint/no-unused-vars */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\"use client\";\n\nimport * as d3 from \"d3\";\nimport { useEffect, useRef, useState } from \"react\";\n\ninterface RotatingEarthProps {\n  width?: number;\n  height?: number;\n  className?: string;\n}\n\nexport default function RotatingEarth({\n  width = 800,\n  height = 600,\n  className = \"\",\n}: RotatingEarthProps) {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [, setIsLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    if (!canvasRef.current) return;\n\n    const canvas = canvasRef.current;\n    const context = canvas.getContext(\"2d\");\n    if (!context) return;\n\n    // Set up responsive dimensions\n    const containerWidth = Math.min(width, window.innerWidth - 40);\n    const containerHeight = Math.min(height, window.innerHeight - 100);\n    const radius = Math.min(containerWidth, containerHeight) / 2.5;\n\n    const dpr = window.devicePixelRatio || 1;\n    canvas.width = containerWidth * dpr;\n    canvas.height = containerHeight * dpr;\n    canvas.style.width = `${containerWidth}px`;\n    canvas.style.height = `${containerHeight}px`;\n    context.scale(dpr, dpr);\n\n    // Create projection and path generator for Canvas\n    const projection = d3\n      .geoOrthographic()\n      .scale(radius)\n      .translate([containerWidth / 2, containerHeight / 2])\n      .clipAngle(90);\n\n    const path = d3.geoPath().projection(projection).context(context);\n\n    const pointInPolygon = (\n      point: [number, number],\n      polygon: number[][],\n    ): boolean => {\n      const [x, y] = point;\n      let inside = false;\n\n      for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {\n        const [xi, yi] = polygon[i];\n        const [xj, yj] = polygon[j];\n\n        if (yi > y !== yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi) {\n          inside = !inside;\n        }\n      }\n\n      return inside;\n    };\n\n    const pointInFeature = (point: [number, number], feature: any): boolean => {\n      const geometry = feature.geometry;\n\n      if (geometry.type === \"Polygon\") {\n        const coordinates = geometry.coordinates;\n        // Check if point is in outer ring\n        if (!pointInPolygon(point, coordinates[0])) {\n          return false;\n        }\n        // Check if point is in any hole (inner rings)\n        for (let i = 1; i < coordinates.length; i++) {\n          if (pointInPolygon(point, coordinates[i])) {\n            return false; // Point is in a hole\n          }\n        }\n        return true;\n      } else if (geometry.type === \"MultiPolygon\") {\n        // Check each polygon in the MultiPolygon\n        for (const polygon of geometry.coordinates) {\n          // Check if point is in outer ring\n          if (pointInPolygon(point, polygon[0])) {\n            // Check if point is in any hole\n            let inHole = false;\n            for (let i = 1; i < polygon.length; i++) {\n              if (pointInPolygon(point, polygon[i])) {\n                inHole = true;\n                break;\n              }\n            }\n            if (!inHole) {\n              return true;\n            }\n          }\n        }\n        return false;\n      }\n\n      return false;\n    };\n\n    const generateDotsInPolygon = (feature: any, dotSpacing = 16) => {\n      const dots: [number, number][] = [];\n      const bounds = d3.geoBounds(feature);\n      const [[minLng, minLat], [maxLng, maxLat]] = bounds;\n\n      const stepSize = dotSpacing * 0.08;\n      let pointsGenerated = 0;\n\n      for (let lng = minLng; lng <= maxLng; lng += stepSize) {\n        for (let lat = minLat; lat <= maxLat; lat += stepSize) {\n          const point: [number, number] = [lng, lat];\n          if (pointInFeature(point, feature)) {\n            dots.push(point);\n            pointsGenerated++;\n          }\n        }\n      }\n\n      console.log(\n        `[v0] Generated ${pointsGenerated} points for land feature:`,\n        feature.properties?.featurecla || \"Land\",\n      );\n      return dots;\n    };\n\n    interface DotData {\n      lng: number;\n      lat: number;\n      visible: boolean;\n    }\n\n    const allDots: DotData[] = [];\n    let landFeatures: any;\n\n    const render = () => {\n      // Clear canvas\n      context.clearRect(0, 0, containerWidth, containerHeight);\n\n      const currentScale = projection.scale();\n      const scaleFactor = currentScale / radius;\n\n      // Draw ocean (globe background)\n      context.beginPath();\n      context.arc(\n        containerWidth / 2,\n        containerHeight / 2,\n        currentScale,\n        0,\n        2 * Math.PI,\n      );\n      context.fillStyle = \"#00000066\";\n      context.fill();\n      context.strokeStyle = \"#80eeb4\";\n      context.lineWidth = 2 * scaleFactor;\n      context.stroke();\n\n      if (landFeatures) {\n        // Draw graticule\n        const graticule = d3.geoGraticule();\n        context.beginPath();\n        path(graticule());\n        context.strokeStyle = \"#80eeb4\";\n        context.lineWidth = 1 * scaleFactor;\n        context.globalAlpha = 0.25;\n        context.stroke();\n        context.globalAlpha = 1;\n\n        // Draw land outlines\n        context.beginPath();\n        landFeatures.features.forEach((feature: any) => {\n          path(feature);\n        });\n        context.strokeStyle = \"#80eeb4\";\n        context.lineWidth = 1 * scaleFactor;\n        context.stroke();\n\n        // Draw halftone dots\n        allDots.forEach((dot) => {\n          const projected = projection([dot.lng, dot.lat]);\n          if (\n            projected &&\n            projected[0] >= 0 &&\n            projected[0] <= containerWidth &&\n            projected[1] >= 0 &&\n            projected[1] <= containerHeight\n          ) {\n            context.beginPath();\n            context.arc(\n              projected[0],\n              projected[1],\n              1.2 * scaleFactor,\n              0,\n              2 * Math.PI,\n            );\n            context.fillStyle = \"#80eeb466\";\n            context.fill();\n          }\n        });\n      }\n    };\n\n    const loadWorldData = async () => {\n      try {\n        setIsLoading(true);\n\n        const response = await fetch(\n          \"https://raw.githubusercontent.com/martynafford/natural-earth-geojson/refs/heads/master/110m/physical/ne_110m_land.json\",\n        );\n        if (!response.ok) throw new Error(\"Failed to load land data\");\n\n        landFeatures = await response.json();\n\n        // Generate dots for all land features\n        let totalDots = 0;\n        landFeatures.features.forEach((feature: any) => {\n          const dots = generateDotsInPolygon(feature, 16);\n          dots.forEach(([lng, lat]) => {\n            allDots.push({ lng, lat, visible: true });\n            totalDots++;\n          });\n        });\n\n        console.log(\n          `[v0] Total dots generated: ${totalDots} across ${landFeatures.features.length} land features`,\n        );\n\n        render();\n        setIsLoading(false);\n      } catch (err) {\n        setError(\"Failed to load land map data\");\n        setIsLoading(false);\n      }\n    };\n\n    // Set up rotation and interaction\n    const rotation: [number, number] = [0, 0];\n    let autoRotate = true;\n    const rotationSpeed = 0.5;\n\n    const rotate = () => {\n      if (autoRotate) {\n        rotation[0] += rotationSpeed;\n        projection.rotate(rotation);\n        render();\n      }\n    };\n\n    // Auto-rotation timer\n    const rotationTimer = d3.timer(rotate);\n\n    const handleMouseDown = (event: MouseEvent) => {\n      autoRotate = false;\n      const startX = event.clientX;\n      const startY = event.clientY;\n      const startRotation: [number, number] = [rotation[0], rotation[1]];\n\n      const handleMouseMove = (moveEvent: MouseEvent) => {\n        const sensitivity = 0.5;\n        const dx = moveEvent.clientX - startX;\n        const dy = moveEvent.clientY - startY;\n\n        rotation[0] = startRotation[0] + dx * sensitivity;\n        rotation[1] = startRotation[1] - dy * sensitivity;\n        rotation[1] = Math.max(-90, Math.min(90, rotation[1]));\n\n        projection.rotate(rotation);\n        render();\n      };\n\n      const handleMouseUp = () => {\n        document.removeEventListener(\"mousemove\", handleMouseMove);\n        document.removeEventListener(\"mouseup\", handleMouseUp);\n\n        setTimeout(() => {\n          autoRotate = true;\n        }, 10);\n      };\n\n      document.addEventListener(\"mousemove\", handleMouseMove);\n      document.addEventListener(\"mouseup\", handleMouseUp);\n    };\n\n    const handleWheel = (event: WheelEvent) => {\n      event.preventDefault();\n      const scaleFactor = event.deltaY > 0 ? 0.9 : 1.1;\n      const newRadius = Math.max(\n        radius * 0.5,\n        Math.min(radius * 3, projection.scale() * scaleFactor),\n      );\n      projection.scale(newRadius);\n      render();\n    };\n\n    canvas.addEventListener(\"mousedown\", handleMouseDown);\n    canvas.addEventListener(\"wheel\", handleWheel);\n\n    // Load the world data\n    loadWorldData();\n\n    // Cleanup\n    return () => {\n      rotationTimer.stop();\n      canvas.removeEventListener(\"mousedown\", handleMouseDown);\n      canvas.removeEventListener(\"wheel\", handleWheel);\n    };\n  }, [width, height]);\n\n  if (error) {\n    return (\n      <div\n        className={`dark flex items-center justify-center bg-card rounded-2xl p-8 ${className}`}\n      >\n        <div className=\"text-center\">\n          <p className=\"dark text-destructive font-semibold mb-2\">\n            Error loading Earth visualization\n          </p>\n          <p className=\"dark text-muted-foreground text-sm\">{error}</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className={`relative ${className}`}>\n      <canvas\n        ref={canvasRef}\n        className=\"w-full h-auto rounded-2xl bg-background dark\"\n        style={{ maxWidth: \"100%\", height: \"auto\" }}\n      />\n      <div className=\"absolute bottom-4 left-4 text-xs text-muted-foreground px-2 py-1 rounded-md dark bg-[#80eeb433]\">\n        Drag to rotate â€¢ Scroll to zoom\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}