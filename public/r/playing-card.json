{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "playing-card",
  "type": "registry:component",
  "dependencies": [
    "three",
    "@react-three/fiber",
    "clsx",
    "tailwind-merge"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "./src/components/nurui/playing-card-demo.tsx",
      "content": "\"use client\";\nimport React, { useState } from \"react\";\nimport PlayingCard from \"@/components/nurui/playing-card\";\n\n// Helper to parse the CSS variable string into an array of RGB arrays\nfunction parseCanvasColors(cssVar: string): number[][] {\n  const raw = cssVar.replace(/['\"]/g, \"\");\n  return raw\n    .split(\";\")\n    .map((group) => group.split(\",\").map((n) => parseInt(n.trim(), 10)))\n    .filter((arr) => arr.length === 3);\n}\n\n// Get CSS variable as string\nfunction getCssVar(varName: string) {\n  return getComputedStyle(document.documentElement)\n    .getPropertyValue(varName)\n    .trim();\n}\n\nexport default function PlayingCardDemo() {\n  const [\n    revealCanvasForPlayingCard,\n    setRevealCanvasForPlayingCardForPlayingCard,\n  ] = useState(false);\n\n  // Read and parse color variables\n  const [canvasColors, setCanvasColors] = useState(() =>\n    parseCanvasColors(getCssVar(\"--playingcard-canvas-colors\")),\n  );\n  const [canvasBg, setCanvasBg] = useState(() =>\n    getCssVar(\"--playingcard-canvas-bg\"),\n  );\n\n  // Optional: Update on theme change if your theme system triggers an event\n  React.useEffect(() => {\n    const update = () => {\n      setCanvasColors(\n        parseCanvasColors(getCssVar(\"--playingcard-canvas-colors\")),\n      );\n      setCanvasBg(getCssVar(\"--playingcard-canvas-bg\"));\n    };\n    window.addEventListener(\"themechange\", update);\n    return () => window.removeEventListener(\"themechange\", update);\n  }, []);\n\n  return (\n    <div className=\"max-w-[440px] mx-auto min-h-[30rem] flex flex-col items-center justify-center \">\n      <div className=\"text-sm\">\n        Click on the card to show/hide dynamic background\n      </div>\n      <PlayingCard\n        componentWidth=\"400px\"\n        aspectRatio=\"3/4\"\n        outerRounding=\"18px\"\n        innerRounding=\"18px\"\n        backgroundColor=\"var(--playingcard-bg)\"\n        foregroundColor=\"var(--playingcard-fg)\"\n        outlineColor=\"var(--playingcard-outline-color)\"\n        hoverOutlineColor=\"var(--playingcard-hover-outline-color)\"\n        textArray={[\"洪\", \"秀\", \"全\"]}\n        minWidth={200}\n        maxWidth={400}\n        minTextSize={16}\n        maxTextSize={24}\n        verticalPadding=\"20px\"\n        horizontalPadding=\"20px\"\n        manualLetterSpacing={-2}\n        componentId=\"card-1\"\n        revealCanvas={revealCanvasForPlayingCard}\n        onCardClicked={() =>\n          setRevealCanvasForPlayingCardForPlayingCard((prev) => !prev)\n        }\n        textColorTransitionDelay=\"1s\"\n        textColorTransitionDuration=\"2.4s\"\n        revealCanvasBackgroundColor={canvasBg}\n        revealCanvasColors={canvasColors}\n        inscriptionColor=\"var(--playingcard-inscription-color)\"\n        inscriptionColorHovered=\"var(--playingcard-inscription-color-hover)\"\n      />\n    </div>\n  );\n}\n",
      "type": "registry:component"
    },
    {
      "path": "./src/components/nurui/playing-card.tsx",
      "content": "\"use client\";\nimport React, { useRef, useEffect, useState, useMemo } from \"react\";\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\nimport * as THREE from \"three\";\nimport { cn } from \"@/lib/utils\";\nimport \"./styles/playing-card.css\";\n\n// --- CanvasRevealEffect and Shader Logic ---\n\ninterface CanvasRevealEffectProps {\n  animationSpeed?: number;\n  opacities?: number[];\n  colors?: number[][];\n  containerClassName?: string;\n  dotSize?: number;\n  showGradient?: boolean;\n  replaceBackground?: boolean;\n  backgroundColor?: string;\n}\n\nconst CanvasRevealEffect: React.FC<CanvasRevealEffectProps> = ({\n  animationSpeed = 0.4,\n  opacities = [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1],\n  colors = [[0, 255, 255]],\n  containerClassName,\n  dotSize,\n  showGradient = true,\n  replaceBackground = false,\n  backgroundColor,\n}) => (\n  <div\n    className={cn(\n      \"absolute inset-0 w-full h-full pointer-events-none\",\n      containerClassName,\n    )}\n    style={{\n      zIndex: 0,\n      borderRadius: \"inherit\",\n      overflow: \"hidden\",\n      background:\n        backgroundColor && !replaceBackground ? backgroundColor : undefined,\n    }}\n  >\n    <DotMatrix\n      colors={colors}\n      dotSize={dotSize ?? 3}\n      opacities={opacities}\n      shader={`\n        float animation_speed_factor = ${animationSpeed.toFixed(1)};\n        float intro_offset = distance(u_resolution / 2.0 / u_total_size, st2) * 0.01 + (random(st2) * 0.15);\n        opacity *= step(intro_offset, u_time * animation_speed_factor);\n        opacity *= clamp((1.0 - step(intro_offset + 0.1, u_time * animation_speed_factor)) * 1.25, 1.0, 1.25);\n      `}\n      center={[\"x\", \"y\"]}\n    />\n    {showGradient && (\n      <>\n        <div\n          className=\"absolute inset-0 bg-gradient-to-t from-gray-950 to-[84%]\"\n          style={{ pointerEvents: \"none\" }}\n        />\n        <div\n          className=\"absolute inset-0 bg-gradient-to-t from-gray-950 to-[84%]\"\n          style={{ pointerEvents: \"none\" }}\n        />\n      </>\n    )}\n  </div>\n);\n\ninterface DotMatrixProps {\n  colors?: number[][];\n  opacities?: number[];\n  totalSize?: number;\n  dotSize?: number;\n  shader?: string;\n  center?: (\"x\" | \"y\")[];\n}\n\nconst DotMatrix: React.FC<DotMatrixProps> = ({\n  colors = [[0, 0, 0]],\n  opacities = [0.04, 0.04, 0.04, 0.04, 0.04, 0.08, 0.08, 0.08, 0.08, 0.14],\n  totalSize = 4,\n  dotSize = 2,\n  shader = \"\",\n  center = [\"x\", \"y\"],\n}) => {\n  const uniforms = useMemo(() => {\n    let colorsArray = [\n      colors[0],\n      colors[0],\n      colors[0],\n      colors[0],\n      colors[0],\n      colors[0],\n    ];\n    if (colors.length === 2) {\n      colorsArray = [\n        colors[0],\n        colors[0],\n        colors[0],\n        colors[1],\n        colors[1],\n        colors[1],\n      ];\n    } else if (colors.length === 3) {\n      colorsArray = [\n        colors[0],\n        colors[0],\n        colors[1],\n        colors[1],\n        colors[2],\n        colors[2],\n      ];\n    }\n    return {\n      u_colors: {\n        value: colorsArray\n          .filter(\n            (color) =>\n              Array.isArray(color) &&\n              color.length === 3 &&\n              color.every((c) => typeof c === \"number\"),\n          )\n          .map((color) => [color[0] / 255, color[1] / 255, color[2] / 255]),\n        type: \"uniform3fv\",\n      },\n      u_opacities: {\n        value: opacities,\n        type: \"uniform1fv\",\n      },\n      u_total_size: {\n        value: totalSize,\n        type: \"uniform1f\",\n      },\n      u_dot_size: {\n        value: dotSize,\n        type: \"uniform1f\",\n      },\n    };\n  }, [colors, opacities, totalSize, dotSize]);\n\n  return (\n    <Shader\n      source={`\n        precision mediump float;\n        in vec2 fragCoord;\n        uniform float u_time;\n        uniform float u_opacities[10];\n        uniform vec3 u_colors[6];\n        uniform float u_total_size;\n        uniform float u_dot_size;\n        uniform vec2 u_resolution;\n        out vec4 fragColor;\n        float PHI = 1.61803398874989484820459;\n        float random(vec2 xy) {\n          return fract(tan(distance(xy * PHI, xy) * 0.5) * xy.x);\n        }\n        float map(float value, float min1, float max1, float min2, float max2) {\n          return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n        }\n        void main() {\n          vec2 st = fragCoord.xy;\n          ${center.includes(\"x\") ? \"st.x -= abs(floor((mod(u_resolution.x, u_total_size) - u_dot_size) * 0.5));\" : \"\"}\n          ${center.includes(\"y\") ? \"st.y -= abs(floor((mod(u_resolution.y, u_total_size) - u_dot_size) * 0.5));\" : \"\"}\n          float opacity = step(0.0, st.x);\n          opacity *= step(0.0, st.y);\n          vec2 st2 = vec2(int(st.x / u_total_size), int(st.y / u_total_size));\n          float frequency = 5.0;\n          float show_offset = random(st2);\n          float rand = random(st2 * floor((u_time / frequency) + show_offset + frequency) + 1.0);\n          opacity *= u_opacities[int(rand * 10.0)];\n          opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.x / u_total_size));\n          opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.y / u_total_size));\n          vec3 color = u_colors[int(show_offset * 6.0)];\n          ${shader}\n          fragColor = vec4(color, opacity);\n          fragColor.rgb *= fragColor.a;\n        }\n      `}\n      uniforms={uniforms}\n      maxFps={60}\n    />\n  );\n};\n\ntype Uniforms = {\n  [key: string]: {\n    value: number | number[] | number[][];\n    type: string;\n  };\n};\n\ninterface ShaderProps {\n  source: string;\n  uniforms: Uniforms;\n  maxFps?: number;\n}\n\nconst ShaderMaterialComponent: React.FC<{\n  source: string;\n  uniforms: Uniforms;\n  maxFps?: number;\n}> = ({ source, uniforms, maxFps = 60 }) => {\n  const { size } = useThree();\n  const ref = useRef<THREE.Mesh>(null);\n  const lastFrameTime = useRef<number>(0);\n\n  useFrame((state: { clock: THREE.Clock }) => {\n    if (!ref.current) return;\n    const timestamp = state.clock.getElapsedTime();\n    if (timestamp - lastFrameTime.current < 1 / maxFps) {\n      return;\n    }\n    lastFrameTime.current = timestamp;\n    const material = ref.current.material as THREE.ShaderMaterial;\n    const timeLocation = material.uniforms.u_time;\n    if (timeLocation) {\n      timeLocation.value = timestamp;\n    }\n  });\n\n  const getUniforms = () => {\n    const preparedUniforms: Record<string, { value: unknown; type?: string }> =\n      {};\n    for (const uniformName in uniforms) {\n      const uniform = uniforms[uniformName];\n      switch (uniform.type) {\n        case \"uniform1f\":\n          preparedUniforms[uniformName] = { value: uniform.value as number };\n          break;\n        case \"uniform3f\":\n          preparedUniforms[uniformName] = {\n            value: new THREE.Vector3().fromArray(uniform.value as number[]),\n          };\n          break;\n        case \"uniform1fv\":\n          preparedUniforms[uniformName] = { value: uniform.value as number[] };\n          break;\n        case \"uniform3fv\":\n          preparedUniforms[uniformName] = {\n            value: (uniform.value as number[][]).map((v) =>\n              new THREE.Vector3().fromArray(v),\n            ),\n          };\n          break;\n        case \"uniform2f\":\n          preparedUniforms[uniformName] = {\n            value: new THREE.Vector2().fromArray(uniform.value as number[]),\n          };\n          break;\n        default:\n          console.error(`Invalid uniform type for '${uniformName}'.`);\n          break;\n      }\n    }\n    preparedUniforms[\"u_time\"] = { value: 0 };\n    preparedUniforms[\"u_resolution\"] = {\n      value: new THREE.Vector2(size.width * 2, size.height * 2),\n    };\n    return preparedUniforms;\n  };\n\n  const material = useMemo(() => {\n    return new THREE.ShaderMaterial({\n      vertexShader: `\n        precision mediump float;\n        in vec2 coordinates;\n        uniform vec2 u_resolution;\n        out vec2 fragCoord;\n        void main(){\n          float x = position.x;\n          float y = position.y;\n          gl_Position = vec4(x, y, 0.0, 1.0);\n          fragCoord = (position.xy + vec2(1.0)) * 0.5 * u_resolution;\n          fragCoord.y = u_resolution.y - fragCoord.y;\n        }\n      `,\n      fragmentShader: source,\n      uniforms: getUniforms(),\n      glslVersion: THREE.GLSL3,\n      blending: THREE.CustomBlending,\n      blendSrc: THREE.SrcAlphaFactor,\n      blendDst: THREE.OneFactor,\n    });\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [size.width, size.height, source]);\n\n  return (\n    <mesh ref={ref}>\n      <planeGeometry args={[2, 2]} />\n      <primitive object={material} attach=\"material\" />\n    </mesh>\n  );\n};\n\nconst Shader: React.FC<ShaderProps> = ({ source, uniforms, maxFps = 60 }) => {\n  return (\n    <Canvas className=\"absolute inset-0 h-full w-full\">\n      <ShaderMaterialComponent\n        source={source}\n        uniforms={uniforms}\n        maxFps={maxFps}\n      />\n    </Canvas>\n  );\n};\n\n// --- useDynamicTextLayout Hook ---\n\nfunction useDynamicTextLayout(\n  containerRef: React.RefObject<HTMLDivElement | null>,\n  textArray: string[],\n  minWidth: number,\n  maxWidth: number,\n  minTextSize: number,\n  maxTextSize: number,\n  manualLetterSpacing: number | undefined,\n  componentId: string,\n) {\n  const [textSize, setTextSize] = useState(maxTextSize);\n  const [letterSpacing, setLetterSpacing] = useState(manualLetterSpacing ?? 0);\n\n  useEffect(() => {\n    const updateTextSize = () => {\n      if (containerRef.current) {\n        const width = containerRef.current.offsetWidth;\n        const calculatedTextSize =\n          ((maxTextSize - minTextSize) / (maxWidth - minWidth)) *\n            (width - minWidth) +\n          minTextSize;\n        const cappedTextSize = Math.min(calculatedTextSize, maxTextSize);\n        setTextSize(cappedTextSize);\n      }\n    };\n    const handleResize = () => {\n      setTimeout(updateTextSize, 500);\n    };\n    const resizeObserver = new ResizeObserver(handleResize);\n    const observedNode = containerRef.current;\n    if (observedNode) {\n      resizeObserver.observe(observedNode);\n    }\n    updateTextSize();\n    return () => {\n      if (observedNode) {\n        resizeObserver.unobserve(observedNode);\n      }\n    };\n  }, [minWidth, maxWidth, minTextSize, maxTextSize, containerRef]);\n\n  useEffect(() => {\n    if (manualLetterSpacing !== undefined) {\n      setLetterSpacing(manualLetterSpacing);\n      return;\n    }\n    const textElement = containerRef.current?.querySelector(\n      `#${componentId}-text`,\n    );\n    if (!textElement) return;\n    const letterHeight =\n      (textElement as HTMLElement).clientHeight / textArray.length;\n    setLetterSpacing(letterHeight);\n  }, [textArray, textSize, manualLetterSpacing, componentId, containerRef]);\n\n  return { textSize, letterSpacing };\n}\n\n// --- PlayingCard Component ---\n\nexport interface PlayingCardProps {\n  componentWidth?: string;\n  aspectRatio?: string;\n  outerRounding?: string;\n  innerRounding?: string;\n  backgroundColor?: string;\n  foregroundColor?: string;\n  outlineColor?: string;\n  hoverOutlineColor?: string;\n  textArray: string[];\n  minWidth: number;\n  maxWidth: number;\n  minTextSize: number;\n  maxTextSize: number;\n  verticalPadding?: string;\n  horizontalPadding?: string;\n  manualLetterSpacing?: number;\n  componentId?: string;\n  onCardClicked: () => void;\n  revealCanvas?: boolean;\n  textColorTransitionDelay?: string;\n  textColorTransitionDuration?: string;\n  revealCanvasBackgroundColor?: string;\n  revealCanvasColors?: number[][];\n  inscriptionColor?: string; // new\n  inscriptionColorHovered?: string; // new\n}\n\nconst PlayingCard: React.FC<PlayingCardProps> = ({\n  componentWidth = \"400px\",\n  aspectRatio = \"9/16\",\n  outerRounding = \"24px\",\n  innerRounding = \"16px\",\n  backgroundColor = \"#FFF\",\n  foregroundColor = \"#000\",\n  outlineColor = \"#E879F9\",\n  hoverOutlineColor = \"#6366F1\",\n  textArray,\n  minWidth,\n  maxWidth,\n  minTextSize,\n  maxTextSize,\n  verticalPadding = \"20px\",\n  horizontalPadding = \"20px\",\n  manualLetterSpacing,\n  componentId = \"card-1\",\n  onCardClicked,\n  revealCanvas = false,\n  textColorTransitionDelay = \"1s\",\n  textColorTransitionDuration = \"2s\",\n  revealCanvasBackgroundColor,\n  revealCanvasColors,\n  inscriptionColor, // new\n  inscriptionColorHovered, // new\n}) => {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [isHovered, setIsHovered] = useState(false);\n\n  // Use the concise hook for text layout\n  const { textSize, letterSpacing } = useDynamicTextLayout(\n    containerRef,\n    textArray,\n    minWidth,\n    maxWidth,\n    minTextSize,\n    maxTextSize,\n    manualLetterSpacing,\n    componentId,\n  );\n\n  // Style for text color transition\n  const textTransition = `color ${textColorTransitionDuration} ease-in-out ${textColorTransitionDelay}`;\n\n  // Border color logic for revealCanvas\n  const borderColor = revealCanvas ? \"#2f2f2f\" : outlineColor;\n  const borderHoverColor = revealCanvas ? \"#3a3a3a\" : hoverOutlineColor;\n\n  // Card background logic for revealCanvas\n  const cardBg = revealCanvas ? \"#000\" : backgroundColor;\n\n  // Inscription color logic (main/mirror)\n  const mainInscriptionColor = isHovered\n    ? inscriptionColorHovered || \"#f12b30\"\n    : inscriptionColor || \"#3662f4\";\n\n  return (\n    <div\n      ref={containerRef}\n      style={{\n        maxWidth: componentWidth,\n        width: \"100%\",\n      }}\n      data-component-id={componentId}\n      onClick={onCardClicked}\n    >\n      <div\n        style={{\n          borderRadius: outerRounding,\n          padding: \"1px\",\n          background: isHovered ? borderHoverColor : borderColor,\n          display: \"inline-block\",\n          width: \"100%\",\n          aspectRatio: aspectRatio,\n          transition: \"background 2s ease-in-out 0.7s\",\n          position: \"relative\",\n        }}\n        onMouseEnter={() => setIsHovered(true)}\n        onMouseLeave={() => setIsHovered(false)}\n      >\n        <div\n          style={{\n            backgroundColor: cardBg,\n            borderRadius: innerRounding,\n            width: \"100%\",\n            height: \"100%\",\n            display: \"flex\",\n            flexDirection: \"column\",\n            color: foregroundColor,\n            position: \"relative\",\n            overflow: \"hidden\",\n            padding: 0,\n          }}\n        >\n          {/* Reveal Canvas Effect - fills the card, always at the back */}\n          {revealCanvas && (\n            <CanvasRevealEffect\n              animationSpeed={5}\n              containerClassName=\"\"\n              colors={\n                revealCanvasColors || [\n                  [236, 72, 153],\n                  [232, 121, 249],\n                ]\n              }\n              dotSize={4}\n              replaceBackground\n              backgroundColor={revealCanvasBackgroundColor}\n            />\n          )}\n          {/* Optional: mask for vignette effect */}\n          {revealCanvas && (\n            <div\n              className=\"absolute inset-0 [mask-image:radial-gradient(400px_at_center,white,transparent)] bg-black/50 dark:bg-black/90 pointer-events-none\"\n              style={{ zIndex: 1 }}\n            />\n          )}\n\n          {/* Main Text */}\n          <div\n            id={`${componentId}-text`}\n            style={{\n              position: \"absolute\",\n              top: verticalPadding,\n              left: horizontalPadding,\n              display: \"flex\",\n              flexDirection: \"column\",\n              zIndex: 2,\n              color: mainInscriptionColor,\n              fontWeight: \"bold\",\n              fontSize: `${textSize}px`,\n              transition: textTransition,\n              pointerEvents: \"none\",\n            }}\n          >\n            {textArray.map((letter, index) => (\n              <div\n                key={`${componentId}-letter-${index}`}\n                style={{\n                  transform:\n                    letterSpacing < 0 && index > 0\n                      ? `translateY(${letterSpacing * index}px)`\n                      : \"none\",\n                  marginBottom:\n                    letterSpacing >= 0 ? `${Math.abs(letterSpacing)}px` : \"0\",\n                  letterSpacing: `${letterSpacing}px`,\n                }}\n              >\n                {letter}\n              </div>\n            ))}\n          </div>\n          {/* Mirrored Text */}\n          <div\n            id={`${componentId}-mirror`}\n            style={{\n              position: \"absolute\",\n              bottom: verticalPadding,\n              right: horizontalPadding,\n              display: \"flex\",\n              flexDirection: \"column\",\n              transform: \"scale(-1)\",\n              zIndex: 2,\n              color: mainInscriptionColor,\n              fontWeight: \"bold\",\n              fontSize: `${textSize}px`,\n              transition: textTransition,\n              pointerEvents: \"none\",\n            }}\n          >\n            {textArray.map((letter, index) => (\n              <div\n                key={`${componentId}-mirror-letter-${index}`}\n                style={{\n                  transform:\n                    letterSpacing < 0 && index > 0\n                      ? `translateY(${letterSpacing * index}px)`\n                      : \"none\",\n                  marginBottom:\n                    letterSpacing >= 0 ? `${Math.abs(letterSpacing)}px` : \"0\",\n                  letterSpacing: `${letterSpacing}px`,\n                }}\n              >\n                {letter}\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default PlayingCard;\n",
      "type": "registry:component"
    },
    {
      "path": "./src/components/nurui/styles/playing-card.css",
      "content": "@import \"tw-animate-css\";\n\n:root {\n  --playingcard-bg: #18192b;\n  --playingcard-fg: #f8fafc;\n  --playingcard-outline-color: #3d3759;\n  --playingcard-hover-outline-color: #7c6ee6;\n  --playingcard-canvas-bg: #23244a;\n  --playingcard-canvas-colors: \"143,108,255;99,102,241;80,115,184\";\n  --playingcard-inscription-color: #00a9fe;\n  --playingcard-inscription-color-hover: #8F04A7;\n}\n\n.dark {\n  --playingcard-bg: #f8fafc;\n  --playingcard-fg: #0f172a;\n  --playingcard-outline-color: #ddd;\n  --playingcard-hover-outline-color: #aaa;\n  --playingcard-canvas-bg: #f8fafc;\n  --playingcard-canvas-colors: \"236,72,153;232,121,249\";\n  --playingcard-inscription-color: #3662f4;\n  --playingcard-inscription-color-hover: #f12b30;\n}",
      "type": "registry:component"
    }
  ]
}