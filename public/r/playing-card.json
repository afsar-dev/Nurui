{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "playing-card",
  "type": "registry:component",
  "dependencies": [
    "three",
    "@react-three/fiber",
    "clsx",
    "tailwind-merge"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "./src/components/nurui/playing-card-demo.tsx",
      "content": "\"use client\";\r\nimport React, { useState } from \"react\";\r\nimport PlayingCard from \"@/components/nurui/playing-card\";\r\n\r\n// Helper to parse the CSS variable string into an array of RGB arrays\r\nfunction parseCanvasColors(cssVar: string): number[][] {\r\n  const raw = cssVar.replace(/['\"]/g, \"\");\r\n  return raw\r\n    .split(\";\")\r\n    .map((group) => group.split(\",\").map((n) => parseInt(n.trim(), 10)))\r\n    .filter((arr) => arr.length === 3);\r\n}\r\n\r\n// Get CSS variable as string\r\nfunction getCssVar(varName: string) {\r\n  return getComputedStyle(document.documentElement)\r\n    .getPropertyValue(varName)\r\n    .trim();\r\n}\r\n\r\nexport default function PlayingCardDemo() {\r\n  const [\r\n    revealCanvasForPlayingCard,\r\n    setRevealCanvasForPlayingCardForPlayingCard,\r\n  ] = useState(false);\r\n\r\n  // Read and parse color variables\r\n  const [canvasColors, setCanvasColors] = useState(() =>\r\n    parseCanvasColors(getCssVar(\"--playingcard-canvas-colors\")),\r\n  );\r\n  const [canvasBg, setCanvasBg] = useState(() =>\r\n    getCssVar(\"--playingcard-canvas-bg\"),\r\n  );\r\n\r\n  // Optional: Update on theme change if your theme system triggers an event\r\n  React.useEffect(() => {\r\n    const update = () => {\r\n      setCanvasColors(\r\n        parseCanvasColors(getCssVar(\"--playingcard-canvas-colors\")),\r\n      );\r\n      setCanvasBg(getCssVar(\"--playingcard-canvas-bg\"));\r\n    };\r\n    window.addEventListener(\"themechange\", update);\r\n    return () => window.removeEventListener(\"themechange\", update);\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"max-w-[440px] mx-auto min-h-[30rem] flex flex-col items-center justify-center \">\r\n      <div className=\"text-sm\">\r\n        Click on the card to show/hide dynamic background\r\n      </div>\r\n      <PlayingCard\r\n        componentWidth=\"400px\"\r\n        aspectRatio=\"3/4\"\r\n        outerRounding=\"18px\"\r\n        innerRounding=\"18px\"\r\n        backgroundColor=\"var(--playingcard-bg)\"\r\n        foregroundColor=\"var(--playingcard-fg)\"\r\n        outlineColor=\"var(--playingcard-outline-color)\"\r\n        hoverOutlineColor=\"var(--playingcard-hover-outline-color)\"\r\n        textArray={[\"洪\", \"秀\", \"全\"]}\r\n        minWidth={200}\r\n        maxWidth={400}\r\n        minTextSize={16}\r\n        maxTextSize={24}\r\n        verticalPadding=\"20px\"\r\n        horizontalPadding=\"20px\"\r\n        manualLetterSpacing={-2}\r\n        componentId=\"card-1\"\r\n        revealCanvas={revealCanvasForPlayingCard}\r\n        onCardClicked={() =>\r\n          setRevealCanvasForPlayingCardForPlayingCard((prev) => !prev)\r\n        }\r\n        textColorTransitionDelay=\"1s\"\r\n        textColorTransitionDuration=\"2.4s\"\r\n        revealCanvasBackgroundColor={canvasBg}\r\n        revealCanvasColors={canvasColors}\r\n        inscriptionColor=\"var(--playingcard-inscription-color)\"\r\n        inscriptionColorHovered=\"var(--playingcard-inscription-color-hover)\"\r\n      />\r\n    </div>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/components/nurui/playing-card.tsx",
      "content": "\"use client\";\r\nimport React, { useRef, useEffect, useState, useMemo } from \"react\";\r\nimport { Canvas, useFrame, useThree } from \"@react-three/fiber\";\r\nimport * as THREE from \"three\";\r\nimport { cn } from \"@/lib/utils\";\r\nimport \"./styles/playing-card.css\";\r\n\r\n// --- CanvasRevealEffect and Shader Logic ---\r\n\r\ninterface CanvasRevealEffectProps {\r\n  animationSpeed?: number;\r\n  opacities?: number[];\r\n  colors?: number[][];\r\n  containerClassName?: string;\r\n  dotSize?: number;\r\n  showGradient?: boolean;\r\n  replaceBackground?: boolean;\r\n  backgroundColor?: string;\r\n}\r\n\r\nconst CanvasRevealEffect: React.FC<CanvasRevealEffectProps> = ({\r\n  animationSpeed = 0.4,\r\n  opacities = [0.3, 0.3, 0.3, 0.5, 0.5, 0.5, 0.8, 0.8, 0.8, 1],\r\n  colors = [[0, 255, 255]],\r\n  containerClassName,\r\n  dotSize,\r\n  showGradient = true,\r\n  replaceBackground = false,\r\n  backgroundColor,\r\n}) => (\r\n  <div\r\n    className={cn(\r\n      \"absolute inset-0 w-full h-full pointer-events-none\",\r\n      containerClassName,\r\n    )}\r\n    style={{\r\n      zIndex: 0,\r\n      borderRadius: \"inherit\",\r\n      overflow: \"hidden\",\r\n      background:\r\n        backgroundColor && !replaceBackground ? backgroundColor : undefined,\r\n    }}\r\n  >\r\n    <DotMatrix\r\n      colors={colors}\r\n      dotSize={dotSize ?? 3}\r\n      opacities={opacities}\r\n      shader={`\r\n        float animation_speed_factor = ${animationSpeed.toFixed(1)};\r\n        float intro_offset = distance(u_resolution / 2.0 / u_total_size, st2) * 0.01 + (random(st2) * 0.15);\r\n        opacity *= step(intro_offset, u_time * animation_speed_factor);\r\n        opacity *= clamp((1.0 - step(intro_offset + 0.1, u_time * animation_speed_factor)) * 1.25, 1.0, 1.25);\r\n      `}\r\n      center={[\"x\", \"y\"]}\r\n    />\r\n    {showGradient && (\r\n      <>\r\n        <div\r\n          className=\"absolute inset-0 bg-gradient-to-t from-gray-950 to-[84%]\"\r\n          style={{ pointerEvents: \"none\" }}\r\n        />\r\n        <div\r\n          className=\"absolute inset-0 bg-gradient-to-t from-gray-950 to-[84%]\"\r\n          style={{ pointerEvents: \"none\" }}\r\n        />\r\n      </>\r\n    )}\r\n  </div>\r\n);\r\n\r\ninterface DotMatrixProps {\r\n  colors?: number[][];\r\n  opacities?: number[];\r\n  totalSize?: number;\r\n  dotSize?: number;\r\n  shader?: string;\r\n  center?: (\"x\" | \"y\")[];\r\n}\r\n\r\nconst DotMatrix: React.FC<DotMatrixProps> = ({\r\n  colors = [[0, 0, 0]],\r\n  opacities = [0.04, 0.04, 0.04, 0.04, 0.04, 0.08, 0.08, 0.08, 0.08, 0.14],\r\n  totalSize = 4,\r\n  dotSize = 2,\r\n  shader = \"\",\r\n  center = [\"x\", \"y\"],\r\n}) => {\r\n  const uniforms = useMemo(() => {\r\n    let colorsArray = [\r\n      colors[0],\r\n      colors[0],\r\n      colors[0],\r\n      colors[0],\r\n      colors[0],\r\n      colors[0],\r\n    ];\r\n    if (colors.length === 2) {\r\n      colorsArray = [\r\n        colors[0],\r\n        colors[0],\r\n        colors[0],\r\n        colors[1],\r\n        colors[1],\r\n        colors[1],\r\n      ];\r\n    } else if (colors.length === 3) {\r\n      colorsArray = [\r\n        colors[0],\r\n        colors[0],\r\n        colors[1],\r\n        colors[1],\r\n        colors[2],\r\n        colors[2],\r\n      ];\r\n    }\r\n    return {\r\n      u_colors: {\r\n        value: colorsArray\r\n          .filter(\r\n            (color) =>\r\n              Array.isArray(color) &&\r\n              color.length === 3 &&\r\n              color.every((c) => typeof c === \"number\"),\r\n          )\r\n          .map((color) => [color[0] / 255, color[1] / 255, color[2] / 255]),\r\n        type: \"uniform3fv\",\r\n      },\r\n      u_opacities: {\r\n        value: opacities,\r\n        type: \"uniform1fv\",\r\n      },\r\n      u_total_size: {\r\n        value: totalSize,\r\n        type: \"uniform1f\",\r\n      },\r\n      u_dot_size: {\r\n        value: dotSize,\r\n        type: \"uniform1f\",\r\n      },\r\n    };\r\n  }, [colors, opacities, totalSize, dotSize]);\r\n\r\n  return (\r\n    <Shader\r\n      source={`\r\n        precision mediump float;\r\n        in vec2 fragCoord;\r\n        uniform float u_time;\r\n        uniform float u_opacities[10];\r\n        uniform vec3 u_colors[6];\r\n        uniform float u_total_size;\r\n        uniform float u_dot_size;\r\n        uniform vec2 u_resolution;\r\n        out vec4 fragColor;\r\n        float PHI = 1.61803398874989484820459;\r\n        float random(vec2 xy) {\r\n          return fract(tan(distance(xy * PHI, xy) * 0.5) * xy.x);\r\n        }\r\n        float map(float value, float min1, float max1, float min2, float max2) {\r\n          return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\r\n        }\r\n        void main() {\r\n          vec2 st = fragCoord.xy;\r\n          ${center.includes(\"x\") ? \"st.x -= abs(floor((mod(u_resolution.x, u_total_size) - u_dot_size) * 0.5));\" : \"\"}\r\n          ${center.includes(\"y\") ? \"st.y -= abs(floor((mod(u_resolution.y, u_total_size) - u_dot_size) * 0.5));\" : \"\"}\r\n          float opacity = step(0.0, st.x);\r\n          opacity *= step(0.0, st.y);\r\n          vec2 st2 = vec2(int(st.x / u_total_size), int(st.y / u_total_size));\r\n          float frequency = 5.0;\r\n          float show_offset = random(st2);\r\n          float rand = random(st2 * floor((u_time / frequency) + show_offset + frequency) + 1.0);\r\n          opacity *= u_opacities[int(rand * 10.0)];\r\n          opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.x / u_total_size));\r\n          opacity *= 1.0 - step(u_dot_size / u_total_size, fract(st.y / u_total_size));\r\n          vec3 color = u_colors[int(show_offset * 6.0)];\r\n          ${shader}\r\n          fragColor = vec4(color, opacity);\r\n          fragColor.rgb *= fragColor.a;\r\n        }\r\n      `}\r\n      uniforms={uniforms}\r\n      maxFps={60}\r\n    />\r\n  );\r\n};\r\n\r\ntype Uniforms = {\r\n  [key: string]: {\r\n    value: number | number[] | number[][];\r\n    type: string;\r\n  };\r\n};\r\n\r\ninterface ShaderProps {\r\n  source: string;\r\n  uniforms: Uniforms;\r\n  maxFps?: number;\r\n}\r\n\r\nconst ShaderMaterialComponent: React.FC<{\r\n  source: string;\r\n  uniforms: Uniforms;\r\n  maxFps?: number;\r\n}> = ({ source, uniforms, maxFps = 60 }) => {\r\n  const { size } = useThree();\r\n  const ref = useRef<THREE.Mesh>(null);\r\n  const lastFrameTime = useRef<number>(0);\r\n\r\n  useFrame((state: { clock: THREE.Clock }) => {\r\n    if (!ref.current) return;\r\n    const timestamp = state.clock.getElapsedTime();\r\n    if (timestamp - lastFrameTime.current < 1 / maxFps) {\r\n      return;\r\n    }\r\n    lastFrameTime.current = timestamp;\r\n    const material = ref.current.material as THREE.ShaderMaterial;\r\n    const timeLocation = material.uniforms.u_time;\r\n    if (timeLocation) {\r\n      timeLocation.value = timestamp;\r\n    }\r\n  });\r\n\r\n  const getUniforms = () => {\r\n    const preparedUniforms: Record<string, { value: unknown; type?: string }> =\r\n      {};\r\n    for (const uniformName in uniforms) {\r\n      const uniform = uniforms[uniformName];\r\n      switch (uniform.type) {\r\n        case \"uniform1f\":\r\n          preparedUniforms[uniformName] = { value: uniform.value as number };\r\n          break;\r\n        case \"uniform3f\":\r\n          preparedUniforms[uniformName] = {\r\n            value: new THREE.Vector3().fromArray(uniform.value as number[]),\r\n          };\r\n          break;\r\n        case \"uniform1fv\":\r\n          preparedUniforms[uniformName] = { value: uniform.value as number[] };\r\n          break;\r\n        case \"uniform3fv\":\r\n          preparedUniforms[uniformName] = {\r\n            value: (uniform.value as number[][]).map((v) =>\r\n              new THREE.Vector3().fromArray(v),\r\n            ),\r\n          };\r\n          break;\r\n        case \"uniform2f\":\r\n          preparedUniforms[uniformName] = {\r\n            value: new THREE.Vector2().fromArray(uniform.value as number[]),\r\n          };\r\n          break;\r\n        default:\r\n          console.error(`Invalid uniform type for '${uniformName}'.`);\r\n          break;\r\n      }\r\n    }\r\n    preparedUniforms[\"u_time\"] = { value: 0 };\r\n    preparedUniforms[\"u_resolution\"] = {\r\n      value: new THREE.Vector2(size.width * 2, size.height * 2),\r\n    };\r\n    return preparedUniforms;\r\n  };\r\n\r\n  const material = useMemo(() => {\r\n    return new THREE.ShaderMaterial({\r\n      vertexShader: `\r\n        precision mediump float;\r\n        in vec2 coordinates;\r\n        uniform vec2 u_resolution;\r\n        out vec2 fragCoord;\r\n        void main(){\r\n          float x = position.x;\r\n          float y = position.y;\r\n          gl_Position = vec4(x, y, 0.0, 1.0);\r\n          fragCoord = (position.xy + vec2(1.0)) * 0.5 * u_resolution;\r\n          fragCoord.y = u_resolution.y - fragCoord.y;\r\n        }\r\n      `,\r\n      fragmentShader: source,\r\n      uniforms: getUniforms(),\r\n      glslVersion: THREE.GLSL3,\r\n      blending: THREE.CustomBlending,\r\n      blendSrc: THREE.SrcAlphaFactor,\r\n      blendDst: THREE.OneFactor,\r\n    });\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [size.width, size.height, source]);\r\n\r\n  return (\r\n    <mesh ref={ref}>\r\n      <planeGeometry args={[2, 2]} />\r\n      <primitive object={material} attach=\"material\" />\r\n    </mesh>\r\n  );\r\n};\r\n\r\nconst Shader: React.FC<ShaderProps> = ({ source, uniforms, maxFps = 60 }) => {\r\n  return (\r\n    <Canvas className=\"absolute inset-0 h-full w-full\">\r\n      <ShaderMaterialComponent\r\n        source={source}\r\n        uniforms={uniforms}\r\n        maxFps={maxFps}\r\n      />\r\n    </Canvas>\r\n  );\r\n};\r\n\r\n// --- useDynamicTextLayout Hook ---\r\n\r\nfunction useDynamicTextLayout(\r\n  containerRef: React.RefObject<HTMLDivElement | null>,\r\n  textArray: string[],\r\n  minWidth: number,\r\n  maxWidth: number,\r\n  minTextSize: number,\r\n  maxTextSize: number,\r\n  manualLetterSpacing: number | undefined,\r\n  componentId: string,\r\n) {\r\n  const [textSize, setTextSize] = useState(maxTextSize);\r\n  const [letterSpacing, setLetterSpacing] = useState(manualLetterSpacing ?? 0);\r\n\r\n  useEffect(() => {\r\n    const updateTextSize = () => {\r\n      if (containerRef.current) {\r\n        const width = containerRef.current.offsetWidth;\r\n        const calculatedTextSize =\r\n          ((maxTextSize - minTextSize) / (maxWidth - minWidth)) *\r\n            (width - minWidth) +\r\n          minTextSize;\r\n        const cappedTextSize = Math.min(calculatedTextSize, maxTextSize);\r\n        setTextSize(cappedTextSize);\r\n      }\r\n    };\r\n    const handleResize = () => {\r\n      setTimeout(updateTextSize, 500);\r\n    };\r\n    const resizeObserver = new ResizeObserver(handleResize);\r\n    const observedNode = containerRef.current;\r\n    if (observedNode) {\r\n      resizeObserver.observe(observedNode);\r\n    }\r\n    updateTextSize();\r\n    return () => {\r\n      if (observedNode) {\r\n        resizeObserver.unobserve(observedNode);\r\n      }\r\n    };\r\n  }, [minWidth, maxWidth, minTextSize, maxTextSize, containerRef]);\r\n\r\n  useEffect(() => {\r\n    if (manualLetterSpacing !== undefined) {\r\n      setLetterSpacing(manualLetterSpacing);\r\n      return;\r\n    }\r\n    const textElement = containerRef.current?.querySelector(\r\n      `#${componentId}-text`,\r\n    );\r\n    if (!textElement) return;\r\n    const letterHeight =\r\n      (textElement as HTMLElement).clientHeight / textArray.length;\r\n    setLetterSpacing(letterHeight);\r\n  }, [textArray, textSize, manualLetterSpacing, componentId, containerRef]);\r\n\r\n  return { textSize, letterSpacing };\r\n}\r\n\r\n// --- PlayingCard Component ---\r\n\r\nexport interface PlayingCardProps {\r\n  componentWidth?: string;\r\n  aspectRatio?: string;\r\n  outerRounding?: string;\r\n  innerRounding?: string;\r\n  backgroundColor?: string;\r\n  foregroundColor?: string;\r\n  outlineColor?: string;\r\n  hoverOutlineColor?: string;\r\n  textArray: string[];\r\n  minWidth: number;\r\n  maxWidth: number;\r\n  minTextSize: number;\r\n  maxTextSize: number;\r\n  verticalPadding?: string;\r\n  horizontalPadding?: string;\r\n  manualLetterSpacing?: number;\r\n  componentId?: string;\r\n  onCardClicked: () => void;\r\n  revealCanvas?: boolean;\r\n  textColorTransitionDelay?: string;\r\n  textColorTransitionDuration?: string;\r\n  revealCanvasBackgroundColor?: string;\r\n  revealCanvasColors?: number[][];\r\n  inscriptionColor?: string; // new\r\n  inscriptionColorHovered?: string; // new\r\n}\r\n\r\nconst PlayingCard: React.FC<PlayingCardProps> = ({\r\n  componentWidth = \"400px\",\r\n  aspectRatio = \"9/16\",\r\n  outerRounding = \"24px\",\r\n  innerRounding = \"16px\",\r\n  backgroundColor = \"#FFF\",\r\n  foregroundColor = \"#000\",\r\n  outlineColor = \"#E879F9\",\r\n  hoverOutlineColor = \"#6366F1\",\r\n  textArray,\r\n  minWidth,\r\n  maxWidth,\r\n  minTextSize,\r\n  maxTextSize,\r\n  verticalPadding = \"20px\",\r\n  horizontalPadding = \"20px\",\r\n  manualLetterSpacing,\r\n  componentId = \"card-1\",\r\n  onCardClicked,\r\n  revealCanvas = false,\r\n  textColorTransitionDelay = \"1s\",\r\n  textColorTransitionDuration = \"2s\",\r\n  revealCanvasBackgroundColor,\r\n  revealCanvasColors,\r\n  inscriptionColor, // new\r\n  inscriptionColorHovered, // new\r\n}) => {\r\n  const containerRef = useRef<HTMLDivElement>(null);\r\n  const [isHovered, setIsHovered] = useState(false);\r\n\r\n  // Use the concise hook for text layout\r\n  const { textSize, letterSpacing } = useDynamicTextLayout(\r\n    containerRef,\r\n    textArray,\r\n    minWidth,\r\n    maxWidth,\r\n    minTextSize,\r\n    maxTextSize,\r\n    manualLetterSpacing,\r\n    componentId,\r\n  );\r\n\r\n  // Style for text color transition\r\n  const textTransition = `color ${textColorTransitionDuration} ease-in-out ${textColorTransitionDelay}`;\r\n\r\n  // Border color logic for revealCanvas\r\n  const borderColor = revealCanvas ? \"#2f2f2f\" : outlineColor;\r\n  const borderHoverColor = revealCanvas ? \"#3a3a3a\" : hoverOutlineColor;\r\n\r\n  // Card background logic for revealCanvas\r\n  const cardBg = revealCanvas ? \"#000\" : backgroundColor;\r\n\r\n  // Inscription color logic (main/mirror)\r\n  const mainInscriptionColor = isHovered\r\n    ? inscriptionColorHovered || \"#f12b30\"\r\n    : inscriptionColor || \"#3662f4\";\r\n\r\n  return (\r\n    <div\r\n      ref={containerRef}\r\n      style={{\r\n        maxWidth: componentWidth,\r\n        width: \"100%\",\r\n      }}\r\n      data-component-id={componentId}\r\n      onClick={onCardClicked}\r\n    >\r\n      <div\r\n        style={{\r\n          borderRadius: outerRounding,\r\n          padding: \"1px\",\r\n          background: isHovered ? borderHoverColor : borderColor,\r\n          display: \"inline-block\",\r\n          width: \"100%\",\r\n          aspectRatio: aspectRatio,\r\n          transition: \"background 2s ease-in-out 0.7s\",\r\n          position: \"relative\",\r\n        }}\r\n        onMouseEnter={() => setIsHovered(true)}\r\n        onMouseLeave={() => setIsHovered(false)}\r\n      >\r\n        <div\r\n          style={{\r\n            backgroundColor: cardBg,\r\n            borderRadius: innerRounding,\r\n            width: \"100%\",\r\n            height: \"100%\",\r\n            display: \"flex\",\r\n            flexDirection: \"column\",\r\n            color: foregroundColor,\r\n            position: \"relative\",\r\n            overflow: \"hidden\",\r\n            padding: 0,\r\n          }}\r\n        >\r\n          {/* Reveal Canvas Effect - fills the card, always at the back */}\r\n          {revealCanvas && (\r\n            <CanvasRevealEffect\r\n              animationSpeed={5}\r\n              containerClassName=\"\"\r\n              colors={\r\n                revealCanvasColors || [\r\n                  [236, 72, 153],\r\n                  [232, 121, 249],\r\n                ]\r\n              }\r\n              dotSize={4}\r\n              replaceBackground\r\n              backgroundColor={revealCanvasBackgroundColor}\r\n            />\r\n          )}\r\n          {/* Optional: mask for vignette effect */}\r\n          {revealCanvas && (\r\n            <div\r\n              className=\"absolute inset-0 [mask-image:radial-gradient(400px_at_center,white,transparent)] bg-black/50 dark:bg-black/90 pointer-events-none\"\r\n              style={{ zIndex: 1 }}\r\n            />\r\n          )}\r\n\r\n          {/* Main Text */}\r\n          <div\r\n            id={`${componentId}-text`}\r\n            style={{\r\n              position: \"absolute\",\r\n              top: verticalPadding,\r\n              left: horizontalPadding,\r\n              display: \"flex\",\r\n              flexDirection: \"column\",\r\n              zIndex: 2,\r\n              color: mainInscriptionColor,\r\n              fontWeight: \"bold\",\r\n              fontSize: `${textSize}px`,\r\n              transition: textTransition,\r\n              pointerEvents: \"none\",\r\n            }}\r\n          >\r\n            {textArray.map((letter, index) => (\r\n              <div\r\n                key={`${componentId}-letter-${index}`}\r\n                style={{\r\n                  transform:\r\n                    letterSpacing < 0 && index > 0\r\n                      ? `translateY(${letterSpacing * index}px)`\r\n                      : \"none\",\r\n                  marginBottom:\r\n                    letterSpacing >= 0 ? `${Math.abs(letterSpacing)}px` : \"0\",\r\n                  letterSpacing: `${letterSpacing}px`,\r\n                }}\r\n              >\r\n                {letter}\r\n              </div>\r\n            ))}\r\n          </div>\r\n          {/* Mirrored Text */}\r\n          <div\r\n            id={`${componentId}-mirror`}\r\n            style={{\r\n              position: \"absolute\",\r\n              bottom: verticalPadding,\r\n              right: horizontalPadding,\r\n              display: \"flex\",\r\n              flexDirection: \"column\",\r\n              transform: \"scale(-1)\",\r\n              zIndex: 2,\r\n              color: mainInscriptionColor,\r\n              fontWeight: \"bold\",\r\n              fontSize: `${textSize}px`,\r\n              transition: textTransition,\r\n              pointerEvents: \"none\",\r\n            }}\r\n          >\r\n            {textArray.map((letter, index) => (\r\n              <div\r\n                key={`${componentId}-mirror-letter-${index}`}\r\n                style={{\r\n                  transform:\r\n                    letterSpacing < 0 && index > 0\r\n                      ? `translateY(${letterSpacing * index}px)`\r\n                      : \"none\",\r\n                  marginBottom:\r\n                    letterSpacing >= 0 ? `${Math.abs(letterSpacing)}px` : \"0\",\r\n                  letterSpacing: `${letterSpacing}px`,\r\n                }}\r\n              >\r\n                {letter}\r\n              </div>\r\n            ))}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PlayingCard;\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/components/nurui/styles/playing-card.css",
      "content": "@import \"tw-animate-css\";\r\n\r\n:root {\r\n  --playingcard-bg: #18192b;\r\n  --playingcard-fg: #f8fafc;\r\n  --playingcard-outline-color: #3d3759;\r\n  --playingcard-hover-outline-color: #7c6ee6;\r\n  --playingcard-canvas-bg: #23244a;\r\n  --playingcard-canvas-colors: \"143,108,255;99,102,241;80,115,184\";\r\n  --playingcard-inscription-color: #00a9fe;\r\n  --playingcard-inscription-color-hover: #8F04A7;\r\n}\r\n\r\n.dark {\r\n  --playingcard-bg: #f8fafc;\r\n  --playingcard-fg: #0f172a;\r\n  --playingcard-outline-color: #ddd;\r\n  --playingcard-hover-outline-color: #aaa;\r\n  --playingcard-canvas-bg: #f8fafc;\r\n  --playingcard-canvas-colors: \"236,72,153;232,121,249\";\r\n  --playingcard-inscription-color: #3662f4;\r\n  --playingcard-inscription-color-hover: #f12b30;\r\n}",
      "type": "registry:component"
    }
  ]
}