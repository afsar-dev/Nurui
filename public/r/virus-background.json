{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "virus-background",
  "type": "registry:component",
  "dependencies": [
    "gsap"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "./src/components/nurui/virus-background-demo.tsx",
      "content": "import React from \"react\";\r\nimport VirusBackground from \"@/components/nurui/virus-background\";\r\n\r\nconst VirusBackgroundDemo = () => {\r\n  return (\r\n    <div className=\"relative flex h-[650px] w-full flex-col items-center justify-center overflow-hidden\">\r\n      <VirusBackground />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default VirusBackgroundDemo;\r\n",
      "type": "registry:component"
    },
    {
      "path": "./src/components/nurui/virus-background.tsx",
      "content": "\"use client\";\r\nimport React, { useEffect, useRef, useCallback } from \"react\";\r\nimport { gsap } from \"gsap\";\r\n\r\nconst vertexShader = `\r\n  attribute vec4 position;\r\n  void main() {\r\n    gl_Position = position;\r\n  }\r\n`;\r\n\r\nconst fragmentShader = `\r\n  precision lowp float;\r\n  uniform float u_time;\r\n  uniform vec2 u_resolution;\r\n  uniform vec2 u_mouse;\r\n  uniform float u_intensity;\r\n\r\n  vec3 hash3(vec2 p) {\r\n    vec3 q = vec3(dot(p, vec2(127.1, 311.7)),\r\n                  dot(p, vec2(269.5, 183.3)),\r\n                  dot(p, vec2(419.2, 371.9)));\r\n    return fract(sin(q) * 43758.5453);\r\n  }\r\n\r\n  float noise(vec2 p) {\r\n    vec2 i = floor(p);\r\n    vec2 f = fract(p);\r\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\r\n    return mix(\r\n      mix(dot(hash3(i + vec2(0.0, 0.0)).xy, f - vec2(0.0, 0.0)),\r\n          dot(hash3(i + vec2(1.0, 0.0)).xy, f - vec2(1.0, 0.0)), u.x),\r\n      mix(dot(hash3(i + vec2(0.0, 1.0)).xy, f - vec2(0.0, 1.0)),\r\n          dot(hash3(i + vec2(1.0, 1.0)).xy, f - vec2(1.0, 1.0)), u.x),\r\n      u.y);\r\n  }\r\n\r\n  float fbm(vec2 p) {\r\n    float value = 0.0;\r\n    float amplitude = 0.5;\r\n    float frequency = 1.0;\r\n    for(int i = 0; i < 6; i++) {\r\n      value += amplitude * noise(p * frequency);\r\n      frequency *= 2.0;\r\n      amplitude *= 0.5;\r\n    }\r\n    return value;\r\n  }\r\n\r\n  float voronoi(vec2 p) {\r\n    vec2 n = floor(p);\r\n    vec2 f = fract(p);\r\n    float md = 50.0;\r\n    for(int i = -1; i <= 1; i++) {\r\n      for(int j = -1; j <= 1; j++) {\r\n        vec2 g = vec2(i, j);\r\n        vec2 o = hash3(n + g).xy;\r\n        o = 0.5 + 0.41 * sin(u_time * 1.5 + 6.28 * o);\r\n        vec2 r = g + o - f;\r\n        float d = dot(r, r);\r\n        md = min(md, d);\r\n      }\r\n    }\r\n    return sqrt(md);\r\n  }\r\n\r\n  vec2 curl(vec2 p) {\r\n    float eps = 0.1;\r\n    float n1 = fbm(p + vec2(eps, 0.0));\r\n    float n2 = fbm(p - vec2(eps, 0.0));\r\n    float n3 = fbm(p + vec2(0.0, eps));\r\n    float n4 = fbm(p - vec2(0.0, eps));\r\n    return vec2((n3 - n4) / (2.0 * eps), (n2 - n1) / (2.0 * eps));\r\n  }\r\n\r\n  float grain(vec2 uv, float time) {\r\n    vec2 seed = uv * time;\r\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\r\n  }\r\n\r\n  void main() {\r\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\r\n    vec2 st = (uv - 0.5) * 2.0;\r\n    st.x *= u_resolution.x / u_resolution.y;\r\n\r\n    float time = u_time * 0.25;\r\n\r\n    vec2 curlForce = curl(st * 2.0) * 0.6;\r\n    vec2 flowField = st + curlForce;\r\n\r\n    float dist = fbm(flowField * 2.0 + time) * 0.6;\r\n\r\n    float cells = voronoi(flowField * 2.5 + time * 0.5);\r\n    cells = smoothstep(0.1, 0.7, cells);\r\n\r\n    float intensity = (1.0 - abs(st.x + dist)) * (1.0 + cells * 0.2) * u_intensity;\r\n\r\n    vec3 baseColor = mix(vec3(1.0, 0.1, 0.6), vec3(0.1, 0.5, 1.0), uv.y);\r\n\r\n    vec3 color = baseColor * intensity;\r\n\r\n    float grainVal = grain(uv, time * 0.5) * 0.2 - 0.1;\r\n    color += grainVal;\r\n\r\n    // Vignette\r\n    float vignette = smoothstep(0.7, 0.0, length(uv - 0.5));\r\n    color *= vignette;\r\n\r\n    // Gamma correction\r\n    color = pow(color, vec3(0.8));\r\n\r\n    gl_FragColor = vec4(color, 1.0);\r\n  }\r\n`;\r\n\r\nexport default function VirusBackground() {\r\n  const canvasRef = useRef<HTMLCanvasElement>(null);\r\n  const mouseRef = useRef({ x: 0, y: 0 });\r\n  const glRef = useRef<WebGLRenderingContext | null>(null);\r\n  const programRef = useRef<WebGLProgram | null>(null);\r\n  const bufferRef = useRef<WebGLBuffer | null>(null);\r\n  const positionLocationRef = useRef<number>(0);\r\n  const timeLocationRef = useRef<WebGLUniformLocation | null>(null);\r\n  const resolutionLocationRef = useRef<WebGLUniformLocation | null>(null);\r\n  const mouseLocationRef = useRef<WebGLUniformLocation | null>(null);\r\n  const intensityLocationRef = useRef<WebGLUniformLocation | null>(null);\r\n  const startTimeRef = useRef<number>(Date.now());\r\n  const intensityRef = useRef<{ current: number }>({ current: 1.0 });\r\n  const animatingRef = useRef<boolean>(false);\r\n\r\n  const createShader = useCallback(\r\n    (gl: WebGLRenderingContext, type: number, source: string) => {\r\n      const shader = gl.createShader(type);\r\n      if (!shader) return null;\r\n      gl.shaderSource(shader, source);\r\n      gl.compileShader(shader);\r\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\r\n        console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\r\n        gl.deleteShader(shader);\r\n        return null;\r\n      }\r\n      return shader;\r\n    },\r\n    [],\r\n  );\r\n\r\n  const initGL = useCallback(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const gl = canvas.getContext(\"webgl\");\r\n    if (!gl) return;\r\n    glRef.current = gl;\r\n\r\n    const vertShader = createShader(gl, gl.VERTEX_SHADER, vertexShader);\r\n    const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShader);\r\n    if (!vertShader || !fragShader) return;\r\n\r\n    const program = gl.createProgram();\r\n    if (!program) return;\r\n    gl.attachShader(program, vertShader);\r\n    gl.attachShader(program, fragShader);\r\n    gl.linkProgram(program);\r\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\r\n      console.error(\"Program link error:\", gl.getProgramInfoLog(program));\r\n      return;\r\n    }\r\n    programRef.current = program;\r\n\r\n    const buffer = gl.createBuffer();\r\n    if (!buffer) return;\r\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n    gl.bufferData(\r\n      gl.ARRAY_BUFFER,\r\n      new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),\r\n      gl.STATIC_DRAW,\r\n    );\r\n    bufferRef.current = buffer;\r\n\r\n    positionLocationRef.current = gl.getAttribLocation(program, \"position\");\r\n    timeLocationRef.current = gl.getUniformLocation(program, \"u_time\");\r\n    resolutionLocationRef.current = gl.getUniformLocation(\r\n      program,\r\n      \"u_resolution\",\r\n    );\r\n    mouseLocationRef.current = gl.getUniformLocation(program, \"u_mouse\");\r\n    intensityLocationRef.current = gl.getUniformLocation(\r\n      program,\r\n      \"u_intensity\",\r\n    );\r\n\r\n    const resizeCanvas = () => {\r\n      const rect = canvas.getBoundingClientRect();\r\n      const dpr = window.devicePixelRatio || 1;\r\n      if (\r\n        canvas.width !== rect.width * dpr ||\r\n        canvas.height !== rect.height * dpr\r\n      ) {\r\n        canvas.width = rect.width * dpr;\r\n        canvas.height = rect.height * dpr;\r\n        gl.viewport(0, 0, canvas.width, canvas.height);\r\n      }\r\n    };\r\n    resizeCanvas();\r\n\r\n    const handleMouseMove = (e: MouseEvent) => {\r\n      const rect = canvas.getBoundingClientRect();\r\n      const dpr = window.devicePixelRatio || 1;\r\n      mouseRef.current.x = (e.clientX - rect.left) * dpr;\r\n      mouseRef.current.y = (rect.height - (e.clientY - rect.top)) * dpr;\r\n\r\n      if (!animatingRef.current) {\r\n        animatingRef.current = true;\r\n        gsap.to(intensityRef.current, {\r\n          value: 1.15,\r\n          duration: 0.3,\r\n          ease: \"power2.out\",\r\n          onUpdate: () => {},\r\n          onComplete: () => {\r\n            gsap.to(intensityRef.current, {\r\n              value: 1.0,\r\n              duration: 1.0,\r\n              ease: \"power2.out\",\r\n              onComplete: () => {\r\n                animatingRef.current = false;\r\n              },\r\n            });\r\n          },\r\n        });\r\n      }\r\n    };\r\n\r\n    window.addEventListener(\"resize\", resizeCanvas);\r\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\r\n\r\n    return () => {\r\n      window.removeEventListener(\"resize\", resizeCanvas);\r\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\r\n    };\r\n  }, [createShader]);\r\n\r\n  useEffect(() => {\r\n    const cleanup = initGL();\r\n\r\n    let animationFrameId: number;\r\n\r\n    const render = () => {\r\n      const time = (Date.now() - startTimeRef.current) * 0.001;\r\n      const gl = glRef.current;\r\n      const program = programRef.current;\r\n      const buffer = bufferRef.current;\r\n\r\n      if (gl && program && buffer) {\r\n        gl.useProgram(program);\r\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\r\n        gl.enableVertexAttribArray(positionLocationRef.current);\r\n        gl.vertexAttribPointer(\r\n          positionLocationRef.current,\r\n          2,\r\n          gl.FLOAT,\r\n          false,\r\n          0,\r\n          0,\r\n        );\r\n\r\n        gl.uniform1f(timeLocationRef.current!, time);\r\n        gl.uniform2f(\r\n          resolutionLocationRef.current!,\r\n          gl.canvas.width,\r\n          gl.canvas.height,\r\n        );\r\n        gl.uniform2f(\r\n          mouseLocationRef.current!,\r\n          mouseRef.current.x,\r\n          mouseRef.current.y,\r\n        );\r\n        gl.uniform1f(\r\n          intensityLocationRef.current!,\r\n          intensityRef.current.current ?? 1.0,\r\n        );\r\n\r\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\r\n      }\r\n\r\n      animationFrameId = requestAnimationFrame(render);\r\n    };\r\n\r\n    render();\r\n\r\n    return () => {\r\n      if (cleanup) cleanup();\r\n      if (animationFrameId) cancelAnimationFrame(animationFrameId);\r\n    };\r\n  }, [initGL]);\r\n\r\n  return (\r\n    <section className=\"relative h-screen w-full overflow-hidden bg-black\">\r\n      <canvas\r\n        ref={canvasRef}\r\n        className=\"absolute inset-0 w-full h-full\"\r\n        style={{ background: \"#000510\" }}\r\n      />\r\n    </section>\r\n  );\r\n}\r\n",
      "type": "registry:component"
    }
  ]
}