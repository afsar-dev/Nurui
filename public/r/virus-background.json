{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "virus-background",
  "type": "registry:component",
  "dependencies": [
    "gsap"
  ],
  "devDependencies": [],
  "registryDependencies": [],
  "files": [
    {
      "path": "./src/components/nurui/virus-background-demo.tsx",
      "content": "import React from \"react\";\nimport VirusBackground from \"@/components/nurui/virus-background\";\n\nconst VirusBackgroundDemo = () => {\n  return (\n    <div className=\"relative flex h-[650px] w-full flex-col items-center justify-center overflow-hidden\">\n      <VirusBackground />\n    </div>\n  );\n};\n\nexport default VirusBackgroundDemo;\n",
      "type": "registry:component"
    },
    {
      "path": "./src/components/nurui/virus-background.tsx",
      "content": "\"use client\";\nimport React, { useEffect, useRef, useCallback } from \"react\";\nimport { gsap } from \"gsap\";\n\nconst vertexShader = `\n  attribute vec4 position;\n  void main() {\n    gl_Position = position;\n  }\n`;\n\nconst fragmentShader = `\n  precision lowp float;\n  uniform float u_time;\n  uniform vec2 u_resolution;\n  uniform vec2 u_mouse;\n  uniform float u_intensity;\n\n  vec3 hash3(vec2 p) {\n    vec3 q = vec3(dot(p, vec2(127.1, 311.7)),\n                  dot(p, vec2(269.5, 183.3)),\n                  dot(p, vec2(419.2, 371.9)));\n    return fract(sin(q) * 43758.5453);\n  }\n\n  float noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n    return mix(\n      mix(dot(hash3(i + vec2(0.0, 0.0)).xy, f - vec2(0.0, 0.0)),\n          dot(hash3(i + vec2(1.0, 0.0)).xy, f - vec2(1.0, 0.0)), u.x),\n      mix(dot(hash3(i + vec2(0.0, 1.0)).xy, f - vec2(0.0, 1.0)),\n          dot(hash3(i + vec2(1.0, 1.0)).xy, f - vec2(1.0, 1.0)), u.x),\n      u.y);\n  }\n\n  float fbm(vec2 p) {\n    float value = 0.0;\n    float amplitude = 0.5;\n    float frequency = 1.0;\n    for(int i = 0; i < 6; i++) {\n      value += amplitude * noise(p * frequency);\n      frequency *= 2.0;\n      amplitude *= 0.5;\n    }\n    return value;\n  }\n\n  float voronoi(vec2 p) {\n    vec2 n = floor(p);\n    vec2 f = fract(p);\n    float md = 50.0;\n    for(int i = -1; i <= 1; i++) {\n      for(int j = -1; j <= 1; j++) {\n        vec2 g = vec2(i, j);\n        vec2 o = hash3(n + g).xy;\n        o = 0.5 + 0.41 * sin(u_time * 1.5 + 6.28 * o);\n        vec2 r = g + o - f;\n        float d = dot(r, r);\n        md = min(md, d);\n      }\n    }\n    return sqrt(md);\n  }\n\n  vec2 curl(vec2 p) {\n    float eps = 0.1;\n    float n1 = fbm(p + vec2(eps, 0.0));\n    float n2 = fbm(p - vec2(eps, 0.0));\n    float n3 = fbm(p + vec2(0.0, eps));\n    float n4 = fbm(p - vec2(0.0, eps));\n    return vec2((n3 - n4) / (2.0 * eps), (n2 - n1) / (2.0 * eps));\n  }\n\n  float grain(vec2 uv, float time) {\n    vec2 seed = uv * time;\n    return fract(sin(dot(seed, vec2(12.9898, 78.233))) * 43758.5453);\n  }\n\n  void main() {\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec2 st = (uv - 0.5) * 2.0;\n    st.x *= u_resolution.x / u_resolution.y;\n\n    float time = u_time * 0.25;\n\n    vec2 curlForce = curl(st * 2.0) * 0.6;\n    vec2 flowField = st + curlForce;\n\n    float dist = fbm(flowField * 2.0 + time) * 0.6;\n\n    float cells = voronoi(flowField * 2.5 + time * 0.5);\n    cells = smoothstep(0.1, 0.7, cells);\n\n    float intensity = (1.0 - abs(st.x + dist)) * (1.0 + cells * 0.2) * u_intensity;\n\n    vec3 baseColor = mix(vec3(1.0, 0.1, 0.6), vec3(0.1, 0.5, 1.0), uv.y);\n\n    vec3 color = baseColor * intensity;\n\n    float grainVal = grain(uv, time * 0.5) * 0.2 - 0.1;\n    color += grainVal;\n\n    // Vignette\n    float vignette = smoothstep(0.7, 0.0, length(uv - 0.5));\n    color *= vignette;\n\n    // Gamma correction\n    color = pow(color, vec3(0.8));\n\n    gl_FragColor = vec4(color, 1.0);\n  }\n`;\n\nexport default function VirusBackground() {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const mouseRef = useRef({ x: 0, y: 0 });\n  const glRef = useRef<WebGLRenderingContext | null>(null);\n  const programRef = useRef<WebGLProgram | null>(null);\n  const bufferRef = useRef<WebGLBuffer | null>(null);\n  const positionLocationRef = useRef<number>(0);\n  const timeLocationRef = useRef<WebGLUniformLocation | null>(null);\n  const resolutionLocationRef = useRef<WebGLUniformLocation | null>(null);\n  const mouseLocationRef = useRef<WebGLUniformLocation | null>(null);\n  const intensityLocationRef = useRef<WebGLUniformLocation | null>(null);\n  const startTimeRef = useRef<number>(Date.now());\n  const intensityRef = useRef<{ current: number }>({ current: 1.0 });\n  const animatingRef = useRef<boolean>(false);\n\n  const createShader = useCallback(\n    (gl: WebGLRenderingContext, type: number, source: string) => {\n      const shader = gl.createShader(type);\n      if (!shader) return null;\n      gl.shaderSource(shader, source);\n      gl.compileShader(shader);\n      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        console.error(\"Shader compile error:\", gl.getShaderInfoLog(shader));\n        gl.deleteShader(shader);\n        return null;\n      }\n      return shader;\n    },\n    [],\n  );\n\n  const initGL = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n\n    const gl = canvas.getContext(\"webgl\");\n    if (!gl) return;\n    glRef.current = gl;\n\n    const vertShader = createShader(gl, gl.VERTEX_SHADER, vertexShader);\n    const fragShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShader);\n    if (!vertShader || !fragShader) return;\n\n    const program = gl.createProgram();\n    if (!program) return;\n    gl.attachShader(program, vertShader);\n    gl.attachShader(program, fragShader);\n    gl.linkProgram(program);\n    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n      console.error(\"Program link error:\", gl.getProgramInfoLog(program));\n      return;\n    }\n    programRef.current = program;\n\n    const buffer = gl.createBuffer();\n    if (!buffer) return;\n    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n    gl.bufferData(\n      gl.ARRAY_BUFFER,\n      new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),\n      gl.STATIC_DRAW,\n    );\n    bufferRef.current = buffer;\n\n    positionLocationRef.current = gl.getAttribLocation(program, \"position\");\n    timeLocationRef.current = gl.getUniformLocation(program, \"u_time\");\n    resolutionLocationRef.current = gl.getUniformLocation(\n      program,\n      \"u_resolution\",\n    );\n    mouseLocationRef.current = gl.getUniformLocation(program, \"u_mouse\");\n    intensityLocationRef.current = gl.getUniformLocation(\n      program,\n      \"u_intensity\",\n    );\n\n    const resizeCanvas = () => {\n      const rect = canvas.getBoundingClientRect();\n      const dpr = window.devicePixelRatio || 1;\n      if (\n        canvas.width !== rect.width * dpr ||\n        canvas.height !== rect.height * dpr\n      ) {\n        canvas.width = rect.width * dpr;\n        canvas.height = rect.height * dpr;\n        gl.viewport(0, 0, canvas.width, canvas.height);\n      }\n    };\n    resizeCanvas();\n\n    const handleMouseMove = (e: MouseEvent) => {\n      const rect = canvas.getBoundingClientRect();\n      const dpr = window.devicePixelRatio || 1;\n      mouseRef.current.x = (e.clientX - rect.left) * dpr;\n      mouseRef.current.y = (rect.height - (e.clientY - rect.top)) * dpr;\n\n      if (!animatingRef.current) {\n        animatingRef.current = true;\n        gsap.to(intensityRef.current, {\n          value: 1.15,\n          duration: 0.3,\n          ease: \"power2.out\",\n          onUpdate: () => {},\n          onComplete: () => {\n            gsap.to(intensityRef.current, {\n              value: 1.0,\n              duration: 1.0,\n              ease: \"power2.out\",\n              onComplete: () => {\n                animatingRef.current = false;\n              },\n            });\n          },\n        });\n      }\n    };\n\n    window.addEventListener(\"resize\", resizeCanvas);\n    canvas.addEventListener(\"mousemove\", handleMouseMove);\n\n    return () => {\n      window.removeEventListener(\"resize\", resizeCanvas);\n      canvas.removeEventListener(\"mousemove\", handleMouseMove);\n    };\n  }, [createShader]);\n\n  useEffect(() => {\n    const cleanup = initGL();\n\n    let animationFrameId: number;\n\n    const render = () => {\n      const time = (Date.now() - startTimeRef.current) * 0.001;\n      const gl = glRef.current;\n      const program = programRef.current;\n      const buffer = bufferRef.current;\n\n      if (gl && program && buffer) {\n        gl.useProgram(program);\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.enableVertexAttribArray(positionLocationRef.current);\n        gl.vertexAttribPointer(\n          positionLocationRef.current,\n          2,\n          gl.FLOAT,\n          false,\n          0,\n          0,\n        );\n\n        gl.uniform1f(timeLocationRef.current!, time);\n        gl.uniform2f(\n          resolutionLocationRef.current!,\n          gl.canvas.width,\n          gl.canvas.height,\n        );\n        gl.uniform2f(\n          mouseLocationRef.current!,\n          mouseRef.current.x,\n          mouseRef.current.y,\n        );\n        gl.uniform1f(\n          intensityLocationRef.current!,\n          intensityRef.current.current ?? 1.0,\n        );\n\n        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);\n      }\n\n      animationFrameId = requestAnimationFrame(render);\n    };\n\n    render();\n\n    return () => {\n      if (cleanup) cleanup();\n      if (animationFrameId) cancelAnimationFrame(animationFrameId);\n    };\n  }, [initGL]);\n\n  return (\n    <section className=\"relative h-screen w-full overflow-hidden bg-black\">\n      <canvas\n        ref={canvasRef}\n        className=\"absolute inset-0 w-full h-full\"\n        style={{ background: \"#000510\" }}\n      />\n    </section>\n  );\n}\n",
      "type": "registry:component"
    }
  ]
}